from django.shortcuts import render, redirect
from twitmining.models import Tweet, Keyword
import twitmining.util.config as config
import requests
from twitmining.forms import KeywordForm
# Create your views here.


def home(request):
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = KeywordForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            Keyword.objects.create(keyword=form.cleaned_data['keyword']).save()
            return redirect('query')

    # if a GET (or any other method) we'll create a blank form
    else:
        form = KeywordForm()

    return render(request, './twitmining/home.html', {'form': form})


def query(request):
    # clean the Tweet table of the DB to put the new tweets generated by the query
    Tweet.objects.all().delete()
    assert len(Tweet.objects.all()) == 0
    assert len(Keyword.objects.all()) != 0

    # get the tweets from the twitter API
    try:
        search_params = {'q': str(Keyword.objects.all()[0]), 'result_type': 'recent', 'count': 5}
        tweets = requests.get(config.search_url, headers=config.search_headers, params=search_params).json()
    except ConnectionError:
        tweets = config.t.search.tweets(q=str(Keyword.objects.all()[0]), count=10)

    # clean the keyword for the next query
    Keyword.objects.all().delete()

    # create links for displaying tweets in the html template
    links = []
    count = 0
    for tweet in tweets['statuses']:
        Tweet.objects.create(id_number=tweet["id_str"]).save()
        links += ['https://twitter.com/TheTwitmining/status/' +
                  str(Tweet.objects.all()[count])]
        count += 1

    return render(request, './twitmining/query.html', {'links': links})
